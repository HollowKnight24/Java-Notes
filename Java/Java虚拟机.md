# Java内存区域
jdk1.8之前：  
线程私有：程序计数器、虚拟机栈、本地方法栈。  
线程共享：堆、方法区、直接内存。  

jdk1.8：  
线程私有：同上。  
线程共享：方法区被元空间取代，元空间在直接内存中。  

程序计数器：记录线程执行的位置，以便多个线程切换时，能知道上次执行到哪。  
Java虚拟机栈：每个Java方法被调用时都会创建一个对应的栈帧，用于存储局部变量表、操作数栈、常量池引用等，方法的调用到执行完成的过程，
对应一个栈帧在虚拟机栈中的入栈和出栈的过程。  
本地方法栈：与虚拟机栈类似，它执行的是native方法。  

堆：Java内存中最大的一块，用于存放实例对象，即为实例对象分配内存。  
垃圾收集器管理的主要区域，因此也成为GC区。  

方法区：也被称为永久代，用于存储虚拟机已加载的信息，如类信息，常量、静态变量等。  

为什么将方法区替换为元空间？  
因为方法区受JVM本身设置的固定大小限制，无法调整。而元空间使用的是直接内存，受本机内存限制，能调整。  

# Java创建对象过程
1.类加载检查：虚拟机遇到new指令时，先去常量池中检查是否有这个类的符号引用，并检查这个类是否已被加载过、解析和初始化过。如果没有就执行相应的类加载过程。  
2.分配内存：在类加载检查后，为新对象分配内存。  
3.初始化零值：内存分配后，需要为分配到的内存空间初始化为零。  
4.设置对象头：初始化零值后，要对对象进行必要的设置，即为对象设置对象头，对象头存放着这个对象是哪个类的实例、类的元数据信息、对象哈希码等信息。  
5.执行init方法：从虚拟机角度来看，一个新对象已经产生，但在Java程序的角度来看，对象创建才刚开始，还没执行<init>方法，所有字段都为0，
  执行init方法，按程序员的意愿进行初始化，一个对象才真正可用。  
  
# 对象访问定位
对象访问定位方法：  
1.使用句柄：堆内存中有一块句柄池，Java程序通过栈上的reference访问对中的对象句柄地址，句柄中又包含了对象实例数据的地址和对象类型数据的地址。  
2.直接指针：reference直接指向对象的地址。  

# 堆内存分配策略
堆分为新生代和老年代，eden区、s0区、s1区属于新生代，tentired属于老年代。  
对象会先被分配在eden区，在一次新生代垃圾回收后，如果还存活则进入survivor区，且年龄加一，当年龄到一定程度（默认15），则进入老年代中。  
大对象和长期存在对象直接进入老年代。  

MinorGC：发生在新生代的垃圾回收动作，比较频繁，回收速度也快。  
FullGC：发生在老年代的垃圾回收，至少伴随一次MinorGC，速度较慢。  

# 判断对象死亡
引用计数法：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。  
两个对象可能出现循环引用，双方计数器永不为0，无法回收，所以不用此法。  

可达性分析算法：以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。  

# 强引用、软引用、弱引用、虚引用
强引用：大部分为强引用，不会被回收，使用new一个对象来创建强引用。  
软引用：内存空间足够不回收，不足则会回收。使用 SoftReference 类来创建软引用。  
弱引用：一定会被回收，因为在下一次垃圾回收中会被扫描到，只能活到下次回收发生前。  
虚引用：任何时候对会被回收，和没有引用一样，无法通过虚引用得到对象。  

# 判断无用的类
方法区中主要回收无用的类，无用的类需满足三个条件：  
该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。  
加载该类的 ClassLoader 已经被回收。  
该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。  

# 垃圾收集算法
标记 - 清除：  
先标记出需要回收的对象，标记完后统一回收，最基础的收集算法。 
效率不高，会产生大量不连续内存碎片。  

标记 - 整理：  
标记过程和 标记 - 清除 算法一样，之后让存活对象都向同一端移动，直接清除掉端之外的内存。  
不会产生大量不连续碎片。  

复制：  
将内存分为相同大小的两块，每次只使用其中一块，回收时将存活对象复制到另一块，再把使用的这块全部清除。  
效率高，但是只使用一半的内存。  

分代收集：  
根据存活周期将内存分为几块，不同块采用适当的算法。  
一般将堆分为新生代和老年代，提高垃圾回收效率。  
新生代使用：复制算法  
老年代使用：标记 - 清除 或者 标记 - 整理 算法  

# 垃圾收集器
7种收集器  
单线程、多线程：  
串行、并行：

Serial 收集器：  
单线程，串行，最基本的收集器，简单高效，工作时必须暂停其他线程。  

ParNew 收集器：  
Serial的多线程版。  

Parallel Scavenge 收集器：  
与ParNew类似，注重吞吐量，低吞吐量，回收频繁；高吞吐量，高效利用cpu时间。  

Serial Old 收集器：  
Serial 收集器的老年代版本。  

Parallel Old 收集器：  
Parallel Scavenge 收集器的老年代版本。  

CMS 收集器：  
获取最短停顿时间为主，是一种 标记-清除 算法实现的，并发收集，低停顿。  

G1 收集器：  
面向服务器，满足停顿时间要求的同时还具有高吞吐量。  

# 类加载过程：
类加载过程：加载->连接->初始化。  
连接又分为三步：验证->准备->解析。  

加载过程：  
1.通过全类名获取定义该类的二进制字节流。  
2.将字节流中代表的静态存储结构转化为方法区运行时的存储结构。  
3.在内存中生成一个代表该类的对象，作为方法区数据的访问入口。  

# 类加载器
三个ClassLoader，都继承java.lang.ClassLoader：  
启动类加载器（Bootstrap ClassLoader）：最顶层加载器，负责加载 %JAVA_HOME%/lib中的jar包和类，或者-Xbootclasspath 参数所指定的路径中的类。  
扩展类加载器（Extension ClassLoader）：负责加载 %JAVA_HOME%/lib/ext中的jar包和类，或者 java.ext.dir系统变量所指定的路径中的类。  
应用程序类加载器（Application ClassLoader）：面向用户的加载器，负责加载当前classpath下的jar包和类。  

# 双亲委派模型
每个类都有自己的类加载器，默认使用双亲委派模型，即类加载时，先判断该类是否被加载过，如有，则直接返回，否则进行加载。  
加载时，先把请求委派给父类加载器处理，因此最后所有请求会自底向上传给顶层的启动类加载器。  
当父类加载器无法处理时，才由自己进行加载。  
能避免类的重复加载。  
