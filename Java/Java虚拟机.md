# Java内存区域
jdk1.8之前：  
线程私有：程序计数器、虚拟机栈、本地方法栈。  
线程共享：堆、方法区、直接内存。  

jdk1.8：  
线程私有：同上。  
线程共享：方法区被元空间取代，元空间在直接内存中。  

程序计数器：记录线程执行的位置，以便多个线程切换时，能知道上次执行到哪。  
Java虚拟机栈：每个Java方法被调用时都会创建一个对应的栈帧，用于存储局部变量表、操作数栈、常量池引用等，方法的调用到执行完成的过程，
对应一个栈帧在虚拟机栈中的入栈和出栈的过程。  
本地方法栈：与虚拟机栈类似，它执行的是native方法。  

堆：Java内存中最大的一块，用于存放实例对象，即为实例对象分配内存。  
垃圾收集器管理的主要区域，因此也成为GC区。  

方法区：也被称为永久代，用于存储虚拟机已加载的信息，如类信息，常量、静态变量等。  

为什么将方法区替换为元空间？  
因为方法区受JVM本身设置的固定大小限制，无法调整。而元空间使用的是直接内存，受本机内存限制，能调整。  

# Java创建对象过程
1.类加载检查：虚拟机遇到new指令时，先去常量池中检查是否有这个类的符号引用，并检查这个类是否已被加载过、解析和初始化过。如果没有就执行相应的类加载过程。  
2.分配内存：在类加载检查后，为新对象分配内存。  
3.初始化零值：内存分配后，需要为分配到的内存空间初始化为零。  
4.设置对象头：初始化零值后，要对对象进行必要的设置，即为对象设置对象头，对象头存放着这个对象是哪个类的实例、类的元数据信息、对象哈希码等信息。  
5.执行init方法：从虚拟机角度来看，一个新对象已经产生，但在Java程序的角度来看，对象创建才刚开始，还没执行<init>方法，所有字段都为0，
  执行init方法，按程序员的意愿进行初始化，一个对象才真正可用。  
  
# 对象访问定位
对象访问定位方法：  
1.使用句柄：堆内存中有一块句柄池，Java程序通过栈上的reference访问对中的对象句柄地址，句柄中又包含了对象实例数据的地址和对象类型数据的地址。  
2.直接指针：reference直接指向对象的地址。  

# 堆内存分配策略
堆分为新生代和老年代，eden区、s0区、s1区属于新生代，tentired属于老年代。  
对象会先被分配在eden区，在一次新生代垃圾回收后，如果还存活则进入survivor区，且年龄加一，当年龄到一定程度（默认15），则进入老年代中。  
大对象和长期存在对象直接进入老年代。  

MinorGC：发生在新生代的垃圾回收动作，比较频繁，回收速度也快。  
FullGC：发生在老年代的垃圾回收，至少伴随一次MinorGC，速度较慢。  






