# 线程
线程：同类的线程共享进程的堆和方法区资源，每个线程都有自己的程序计数器，虚拟机栈、本地方法栈。  

程序计数器：用于记录当前线程执行的位置，线程来回切换时能知道当前线程运行到哪，所以是线程私有的。  
虚拟机栈：一个线程有很多方法，每个方法执行时都会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等，方法的调用到执行完成对应着一个栈帧在虚拟机栈中的入栈和出栈过程。  
本地方法栈：和虚拟机栈类似，对应的是native方法。  

堆和方法区是所有线程共享的资源，堆是进程中最大的内存块，用于存放新创建的对象，方法区用于存放已被加载的信息，如类信息、常量，静态变量等。  

并发：同一时间段内，多个任务在执行。  
并行：同一单位时间内，多个任务同时执行。  

线程状态：  
NEW（新建）：  
RUNABLE（运行）：  
BLOCKED（阻塞）：  
WAITING（等待）：  
TIMED_WAITING（限时等待）：  
TERMINATED（终止）：  

NEW创建后，调用start（）获得时间片后进入RUNABLE运行状态，执行wait（）后，线程进入WAITING，等其他线程通知后才能回到RUNABLE运行，当调用同步方法没有获得锁时，进入BLOCKED（阻塞），
运行时执行run（）后进入TERMINATED终止。  

上下文切换：  
当前任务执行完自己的时间片后，保存自己执行的状态后，切换到其他任务执行，当其他任务执行完成后，切换回来再加载这个任务的状态。  

# 死锁
死锁：多个线程因都在等待其他线程的资源而进入阻塞，都在互相等待从而进入无限期阻塞。  

死锁产生的条件：  
互斥：一个资源同一时间内只能被一个线程占用。  
请求与保持：线程请求其他资源而阻塞时，不释放自己持有的资源。  
不剥夺：线程自己未使用完的资源不会被其他线程强行剥夺。  
循环等待：多个进程之间形成头尾相连，循环等待资源的关系。  

# sleep（）和wait（）
两者都能暂停线程的执行。  
sleep没有释放锁，wait释放锁。  
wait调用后，线程不会自动苏醒，需要别的对象通知它，即调用notify或notifyAll。  
sleep会自动苏醒。  

# 为什么不直接执行run（），要执行start（）
新建一个线程后，执行start会使线程进入就绪状态，分配到时间片后会自动执行run，是多线程工作。  
直接执行run，只会执行main线程下的普通方法run，即只执行主线程，并不是多线程工作。  

# synchronized
解决多线程访问资源的同步性。  
可保证被修饰的方法或代码块任意时刻只能被一个线程执行。  

# volatile
保证变量可见性，每次使用这个变量都要到共享内存中读取。    
一个线程从共享内存读取一个变量后将它存储到本地内存，结果共享内存内的这个变量改变了，而这个线程还在使用本地内存的这个变量，造成数据不一致。  
也能保证代码的有序性，即按照编写的顺序执行。  

# 使用线程
有三种使用线程的方法：  

实现 Runnable 接口；  
实现 Callable 接口；  
继承 Thread 类。  

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。  

# 中断
线程通过调用 interrupt() 来中断，如果该线程处于阻塞或等待状态，就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。  

# synchronized和ReentrantLock
synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。  

等待可中断：  
当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。  
ReentrantLock 可中断，而 synchronized 不行。    

# 锁
公平锁：  
公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。  
synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

乐观锁/悲观锁：
乐观锁认为对同一数据的并发操作不会发生修改，不需要加锁，适合读操作多的场景。  
悲观锁认为对同一数据并发操作会发生修改，需要加锁，适合写操作多的场景。  

独享锁/共享锁：
独享锁指一次只能被一个线程拥有，如synchronized和ReentrantLock以及ReentrantReadWriteLock的写锁。  
共享锁一次能被多个线程拥有，如ReentrantReadWriteLock的读锁。  

可重入锁：
一个线程在外层方法获得锁时，进入内层方法会自动获得锁，可避免死锁。  

自旋锁：互斥同步进入阻塞开销很大，应尽量避免进入阻塞。自旋锁就是让一个线程在请求共享数据的锁时，进入忙循环一段时间，采用循环方式去尝试获得锁，如果在这段时间内获得锁，就可以避免进入阻塞，适用于共享数据锁定状态很短的场景。  
锁消除：对不存在竞争的共享数据的锁的消除。  

偏向锁/轻量级锁/重量级锁：
偏向锁：一段代码一直被同一线程访问，那么该线程会自动获得锁。  
轻量级锁：当偏向锁被另一线程访问时，会升级为轻量级锁，其他线程会通过自旋的方式尝试获得锁，不会进入阻塞。  
重量级锁：轻量级锁被其他线程访问时，其他线程自旋到一定次数后会进入阻塞，该锁就升级会重量级锁，其他线程访问时就会进入阻塞。  

# CAS
CAS全称是Compare and Swap，即比较并交换。  
包含3个操作数，内存地址V，预期值A，新值B，每次操作的时候比较下内存地址的值是否和预期值一样，一样则更新，不一样则不做操作。  
即更新前先确认下所取的值是否变化过，没变化则更新。  
ABA问题：即一个值原本是A，后来修改为B又修改回A，则进行CAS时就会认为这个值没变化过，实际上变化过了。可以通过加版本号的方式来解决这个问题。  

# AQS
核心思想：如果被请求的共享资源空闲，则将请求的线程设置为有效工作线程，资源设置为锁定状态。当被锁定的资源被请求时，将暂时获取不到锁的线程加入到CLH队列中来进行锁的分配。  
CLH队列是双向队列，FIFO原则。  
