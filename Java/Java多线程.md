# 线程
线程：同类的线程共享进程的堆和方法区资源，每个线程都有自己的程序计数器，虚拟机栈、本地方法栈。  

程序计数器：用于记录当前线程执行的位置，线程来回切换时能知道当前线程运行到哪，所以是线程私有的。  
虚拟机栈：一个线程有很多方法，每个方法执行时都会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等，方法的调用到执行完成对应着一个栈帧在虚拟机栈中的入栈和出栈过程。  
本地方法栈：和虚拟机栈类似，对应的是native方法。  

堆和方法区是所有线程共享的资源，堆是进程中最大的内存块，用于存放新创建的对象，方法区用于存放已被加载的信息，如类信息、常量，静态变量等。  

并发：同一时间段内，多个任务在执行。  
并行：同一单位时间内，多个任务同时执行。  

线程状态：  
NEW（新建）：  
RUNABLE（运行）：  
BLOCKED（阻塞）：  
WAITING（等待）：  
TIMED_WAITING（限时等待）：  
TERMINATED（终止）：  

NEW创建后，调用start（）获得时间片后进入RUNABLE运行状态，执行wait（）后，线程进入WAITING，等其他线程通知后才能回到RUNABLE运行，当调用同步方法没有获得锁时，进入BLOCKED（阻塞），
运行时执行run（）后进入TERMINATED终止。  

上下文切换：  
当前任务执行完自己的时间片后，保存自己执行的状态后，切换到其他任务执行，当其他任务执行完成后，切换回来再加载这个任务的状态。  

# 死锁
死锁：多个线程因都在等待其他线程的资源而进入阻塞，都在互相等待从而进入无限期阻塞。  

死锁产生的条件：  
互斥：一个资源同一时间内只能被一个线程占用。  
请求与保持：线程请求其他资源而阻塞时，不释放自己持有的资源。  
不剥夺：线程自己未使用完的资源不会被其他线程强行剥夺。  
循环等待：多个进程之间形成头尾相连，循环等待资源的关系。  

# sleep（）和wait（）
两者都能暂停线程的执行。  
sleep没有释放锁，wait释放锁。  
wait调用后，线程不会自动苏醒，需要别的对象通知它，即调用notify或notifyAll。  
sleep会自动苏醒。  

# 为什么不直接执行run（），要执行start（）
新建一个线程后，执行start会使线程进入就绪状态，分配到时间片后会自动执行run，是多线程工作。  
直接执行run，只会执行main线程下的普通方法run，即只执行主线程，并不是多线程工作。  

# synchronized
解决多线程访问资源的同步性。  
可保证被修饰的方法或代码块任意时刻只能被一个线程执行。  

# volatile
保证变量可见性，每次使用这个变量都要到共享内存中读取。    
一个线程从共享内存读取一个变量后将它存储到本地内存，结果共享内存内的这个变量改变了，而这个线程还在使用本地内存的这个变量，造成数据不一致。  
也能保证代码的有序性，即按照编写的顺序执行。  

# 使用线程
有三种使用线程的方法：  

实现 Runnable 接口；  
实现 Callable 接口；  
继承 Thread 类。  

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。  

# 中断
线程通过调用 interrupt() 来中断，如果该线程处于阻塞或等待状态，就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。  

# synchronized和ReentrantLock
synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。  

等待可中断：  
当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。  
ReentrantLock 可中断，而 synchronized 不行。  

公平锁：  
公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。  
synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。  



