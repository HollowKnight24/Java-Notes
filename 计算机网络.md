# 计算机网络体系结构
五层协议：  
应用层  
运输层  
网络层  
数据链路层  
物理层  

OSI七层协议：
即在五层协议中的应用层和运输层中间加两层，表示层和会话层。 

应用层  

表示层  
会话层  

运输层  
网络层  
数据链路层  
物理层  

TCP/IP四层协议：  
相当于把五层协议的数据链路层和物理层合为网络接口层。  

应用层  
运输层  
网络层  
网络接口层  

一般使用五层结构：  

应用层：为特定应用程序提供数据传输服务，即定义应用进程之间的通信和交互规则。  
如域名系统DNS、HTTP协议、SMTP协议。  
数据单位为报文。  

运输层：负责向两台主机之间的进程的通信提供通用的数据传输服务。  
主要有TCP、UDP两种协议。  
数据单位为报文段。  

网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。  
IP协议。  
数据单位为IP数据报。  

数据链路层：主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。  
数据单位为帧。  

物理层：实现计算机节点之间比特流的透明传输，尽可能屏蔽具体传输介质和物理设备的差异。  
数据单位为比特。  

# TCP的三次握手和四次挥手
三次握手：  
客户端发送带有SYN的数据包给服务端，一次握手。  
服务端发送带有SYN/ACK的数据包给客户端，二次握手。  
客户端再发送带有ACK的数据包给服务端，三次握手。  

为什么要三次握手？  
主要是确认双方的发送与接收都正常。  
第一次握手，客户端什么都没确认，服务端只确认了自己的接收和对方的发送正常。  
第二次握手，客户端确认了自己的接收发送和对方的接收发送都正常。  
第三次握手，服务端确认了全部正常。  

为什么要SYN和ACK？  
SYN是为了告诉发送端，我收到的确实是你的信息。  
ACK是因为，SYN只确认了发送方到接收方的通道没问题，而ACK是为了确认接收方到发送方的通道没问题。  

四次挥手： 
客户端发送FIN给服务端请求关闭连接，一次挥手。  
服务端收到后，发回一个带有ACK和确认序号+1的数据， 二次挥手。  
服务端接着发送一个FIN给客户端请求关闭连接，三次挥手。  
客户端收到后，同样发回一个带有ACK和确认序号+1的数据， 四次挥手。 
服务端收到后关闭连接。  

为什么要四次？  
因为客户端释放连接后，处于半关闭状态，即只能接收数据，不能发送，为了等服务端未发送完的数据及确认过来。  
同样的服务端数据发送完后，释放连接，也处于半关闭状态，等客户端确认后，则可以完全关闭连接。  

# TCP和UDP
UDP：无连接，面向报文（数据报），不提供可靠交付。  
一般用于即时通信，如语音，视频，直播等。  

TCP：面向连接，提供可靠交付，面向字节流，有流量控制，拥塞控制。  
一般用于文件传输、邮件发送接收、远程登入等。  

TCP如何保证可靠传输？  
1.为发送的每个包编号，接收方排序，有序传给应用层。  
2.校验和，保持首部和数据的校验和，如果收到的校验和有错，则丢弃，不确认收到。  
3.丢弃重复接收的数据。  
4.流量控制：利用滑动窗口实现，接收方有固定大小的缓存空间，发送方只能发送接收方缓冲区能接纳的数据，当接收方来不及接收，会提示发送方降低发送速率，避免丢包。  
5.拥塞控制：网络拥塞时，减少发送。  
6.AQR协议：每发送完一个分组就停下，等对方确认后再发送。  
7.超时重传：当发送一个报文后，会启动一个计时器，等待对方确认收到，如没有及时收到，则重新发送。  

AQR协议：  
停止等待AQR：每发送完一个分组就等待确认，一段时间没收到就超时重传，丢弃重复接收的分组。  
连续等待AQR：发送方维持一个发送窗口，在窗口内的即可发送，无需等待对方确认，接收方采用累计确认，对按序到达的最后一个分组进行确认，说明到这个分组为止的所有分组都收到了。  

滑动窗口：实现流量控制，控制发送方速率，接收方利用发送报文中窗口字段来控制发送方的窗口大小。  
拥塞控制：发送方维持一个拥塞窗口（cwnd），大小取决于网络拥塞程度。采用慢开始、拥塞避免、快重传、快恢复四种算法。  

慢开始：cwnd初始值为1，收到确认后每次翻倍。  
拥塞避免：为慢开始设置一个门限 ssthresh，如果cwnd》= ssthresh则进入拥塞避免，让cwnd每次只+1，如果出现超时，则 ssthresh = cwnd/2，然后重新开始慢开始。  
快重传与快恢复：发送方收到三个重复的确认，则进入快重传，立即重新发送下一个报文。这种只丢失个别报文，则进入快恢复，令 ssthresh = cwnd/2，再令cwnd =  ssthresh，然后进入拥塞避免。  

# 在浏览器输入url到出现网页的过程
1.浏览器通过DNS解析获取域名的ip。  
2.与服务器建立TCP连接。  
3.发送HTTP请求。  
4.服务器处理请求，返回HTTP报文。  
5.浏览器解析渲染页面。  

# 状态码
1XX 信息状态码 请求正在处理  
2XX 成功状态码 请求处理完毕 如 200 OK  
3XX 重定向状态码 需要附加操作以完成请求 如 301 Moved Permanently  
4XX 客户端错误状态码 服务器无法处理请求 400 Bad Request, 404 Not Found  
5XX 服务器错误状态码 服务器处理请求出错 500 Internal Server Error  

# HTTP
短连接：HTTP/1.0默认短连接，一个网页有多种资源，每请求一个资源就进行一次HTTP操作，就要建立一次TCP连接，任务结束就断开连接。  
长连接：HTTP/1.1默认长连接，一个网页打开后，HTTP传输的TCP连接可以长时间保持连接，即一次连接就能请求多个资源，支持流水线方式。  

Session：HTTP为无状态协议，不保存通信状态，session就是要解决这个问题。  
主要用于服务端记录用户状态，能在一定时间内保存这个session。  

Cookie和Session：都是用来跟踪浏览器用户身份的会话方式，应用场景不一样。  
Cookie一般用来保存用户信息，比如保存登陆信息，下次自动填写登陆信息或者下次自动登陆，保存在客户端中。  
Session：服务端记录用户状态，如购物车，服务端为特定用户创建一个Session，就能跟踪这个用户了，保存在服务端中。  

HTTP和HTTPS：  
HTTP的URL默认80端口，HTTPS默认443端口。  
HTTPS比HTTP安全性高，因为https对信息加密了，使用对称加密。  

对称加密：加密解密为同一密码。  
非对称加密：密钥成对，公钥和私钥，加密解密不同密码。  

URI和URL  
URI：统一资源标识符，标识一个资源。  
URL：统一资源定位符，是一种具体的URI，不仅标识了资源，还能定位，提供资源地址。  

GET和POST  
GET：获取资源，参数在URL中，安全。  
POST：传输实体主体内容，不安全。  

# Socket
不同主机应用进程之间进行双向通信的端点的抽象，一个套接字就是通信的一端，需要有ip和port。  
